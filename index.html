<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Flip Jump Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />
    <style>
      body {
        font-family: "Poppins", sans-serif;
        margin: 0;
        padding: 0;
        height: 100dvh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: #1a202c;
        color: white;
        overflow: hidden;
      }
      #app-container {
        position: relative;
        height: 100dvh;
        max-width: 100vw;
        aspect-ratio: 9 / 16;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      #game-container {
        width: 100%;
        height: 100%;
        background: #2d3748;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        overflow: hidden;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
      #controls {
        position: absolute;
        bottom: 5%;
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 20px;
        box-sizing: border-box;
        z-index: 20;
      }
      .control-btn {
        width: 70px;
        height: 70px;
        background-color: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        transition:
          background-color 0.1s ease,
          transform 0.1s ease;
        user-select: none;
        -webkit-user-select: none;
      }
      .control-btn:active {
        background-color: rgba(255, 255, 255, 0.4);
        transform: scale(0.95);
      }
      #move-controls {
        display: flex;
        gap: 20px;
      }
      .instructions {
        position: absolute;
        top: 7%;
        left: 0;
        right: 0;
        text-align: center;
        padding: 0 1rem;
        z-index: 20;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      #ammo-display {
        font-size: 1.25rem;
        font-weight: 600;
        margin-top: 0.5rem;
        background-color: rgba(0, 0, 0, 0.3);
        padding: 0.25rem 1rem;
        border-radius: 9999px;
      }
      #health-display {
        position: absolute;
        top: 10px;
        left: 10px;
        display: flex;
        gap: 5px;
      }
      .health-unit {
        width: 20px;
        height: 20px;
        background-color: #f56565;
        border-radius: 2px;
      }
      #score-display {
        position: absolute;
        top: 10px;
        right: 10px;
        font-size: 1.25rem;
        font-weight: 600;
        background-color: rgba(0, 0, 0, 0.3);
        padding: 0.25rem 1rem;
        border-radius: 9999px;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
  </head>
  <body class="bg-gray-900 text-white">
    <div id="app-container">
      <div class="instructions">
        <p class="text-lg font-semibold">Tap to jump. Tap again in mid-air to shoot!</p>
        <div id="ammo-display">Ammo: 8/8</div>
      </div>

      <div id="game-container" class="shadow-2xl">
        <canvas id="gameCanvas"></canvas>
        <div id="health-display"></div>
        <div id="score-display">Score: 0</div>
      </div>

      <div id="controls">
        <div id="move-controls">
          <button id="left-btn" class="control-btn">
            <!-- left arrow SVG -->
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="32"
              height="32"
              fill="currentColor"
              class="bi bi-arrow-left"
              viewBox="0 0 16 16"
            >
              <path
                fill-rule="evenodd"
                d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8z"
              />
            </svg>
          </button>
          <button id="right-btn" class="control-btn">
            <!-- right arrow SVG -->
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="32"
              height="32"
              fill="currentColor"
              class="bi bi-arrow-right"
              viewBox="0 0 16 16"
            >
              <path
                fill-rule="evenodd"
                d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z"
              />
            </svg>
          </button>
        </div>
        <div id="jump-control">
          <button id="jump-btn" class="control-btn">
            <!-- down arrow SVG -->
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="32"
              height="32"
              fill="currentColor"
              class="bi bi-arrow-down"
              viewBox="0 0 16 16"
            >
              <path
                d="M8 1a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L7.5 13.293V1.5A.5.5 0 0 1 8 1z"
              />
            </svg>
          </button>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const gameContainer = document.getElementById("game-container");
      const leftBtn = document.getElementById("left-btn");
      const rightBtn = document.getElementById("right-btn");
      const jumpBtn = document.getElementById("jump-btn");
      const ammoDisplay = document.getElementById("ammo-display");
      const healthDisplay = document.getElementById("health-display");
      const scoreDisplay = document.getElementById("score-display");

      // --- Image Loading ---
      const blockImage = new Image();
      blockImage.src = "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f2822e07-b744-4bb2-842d-f6b4bd842647/block-bNl3WWgsBKqF75lkexi8dOq8RJp9Il.png";
      let imageLoaded = false;
      
      blockImage.onload = () => {
        imageLoaded = true;
      };
      
      blockImage.onerror = () => {
        console.warn("Failed to load block image, using fallback rendering");
        imageLoaded = false;
      };

      // --- Audio ---
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      function createSound(type, frequency, duration) {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.type = type;
        oscillator.frequency.value = frequency;
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        return {
          play: () => {
            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
          }
        };
      }
      
      const shootSound = () => createSound('square', 220, 0.1).play();
      const landSound = () => createSound('sine', 150, 0.2).play();
      const hitSound = () => createSound('square', 100, 0.3).play();
      const pickupSound = () => createSound('sine', 440, 0.2).play();

      // --- Game Configuration ---
      const normalGravity = 0.55; // Reduced from 0.6 to make jumps feel lighter
      const reducedGravity = 0.1; // Reduced from 0.1 for smoother floating
      const jumpStrength = -13; // Stronger initial jump (was -13)
      const constantFallSpeed = 15; // Reduced from 15 for less aggressive falling
      const maxFallingSpeed = 15;   // Reduced from 15 to match constantFallSpeed
      const playerSize = 30;
      const playerSpeed = 7;
      const playerColor = "#4299e1";
      const initialGroundHeight = 50;
      const maxAmmo = 8;
      const bulletSpeed = 25; // Increased from 10 for faster bullets
      const bulletSize = 10; // Increased from 5 for larger bullets
      const bulletLifetime = 500; // New: 1.5 seconds lifetime for bullets
      const screenShakeDuration = 10; // New: milliseconds of screen shake
      const screenShakeIntensity = 5; // New: pixels of screen shake
      
      // Add these new properties
      let screenShake = 0;
      let screenShakeX = 0;
      let screenShakeY = 0;
      const shootCooldown = 100; // ms
      const initialHealth = 4;
      const blockSize = Math.round(playerSize * 1.5);
      const enemySize = 22;
      const enemyProjectileSize = 6;
      const enemyShootRate = 120; // Higher = less frequent
      const enemyProjectileSpeed = 3;
      const pickupSize = 10;
      const pickupValue = 50; // Score points
      const enemyValue = 100; // Score points
      const pickupDropChance = 0.3; // 30% chance
      const blockDestructionValue = 15; // Score points for destroying a block

      // --- Cached canvas dimensions ---
      let canvasW = 0;
      let canvasH = 0;
      let dpr = window.devicePixelRatio || 1;
      let groundY = 0;
      
      // --- Game State ---
      let gameStarted = false;
      let gameOver = false;
      let score = 0;
      let depthTraveled = 0;
      let fallSpeed = 1; // Initial vertical scroll speed
      let maxFallSpeed = 4; // Maximum vertical scroll speed
      let fallSpeedIncreaseRate = 0.0001; // How quickly fall speed increases

      // --- Camera System ---
      let cameraY = 0;

      // --- Player State ---
      let player = {
        x: 0,
        y: 0,
        width: playerSize,
        height: playerSize,
        velocityX: 0,
        velocityY: 0,
        ammo: maxAmmo,
        health: initialHealth,
        canJump: true,
        invulnerable: 0, // Invulnerability frames after getting hit
      };

      // --- Game Objects ---
      let bullets = [];
      let blocks = []; // Individual platform blocks
      let platforms = []; // Platform configurations (templates)
      let enemies = [];
      let enemyProjectiles = [];
      let pickups = [];
      
      // --- Control State ---
      let isMovingLeft = false;
      let isMovingRight = false;
      let isJumpButtonPressed = false;
      let shootPermissionGranted = false;
      let lastShotTime = 0;
      let lastAmmo = player.ammo;
      let lastHealth = player.health;

      // --- Pre-build paths ---
      const playerPath = (() => {
        const path = new Path2D();
        const w = playerSize,
          h = playerSize,
          r = 10;
        path.moveTo(-w / 2 + r, -h / 2);
        path.arcTo(w / 2, -h / 2, w / 2, h / 2, r);
        path.arcTo(w / 2, h / 2, -w / 2, h / 2, r);
        path.arcTo(-w / 2, h / 2, -w / 2, -h / 2, r);
        path.arcTo(-w / 2, -h / 2, w / 2, -h / 2, r);
        path.closePath();
        return path;
      })();
      
      const enemyPath = (() => {
        const path = new Path2D();
        const size = enemySize;
        const halfSize = size / 2;
        
        // Draw a simple square shape
        path.rect(-halfSize, -halfSize, size, size);
        
        return path;
      })();

      // --- Platform Generation ---
      function createPlatformBlocks(x, y, cols, rows) {
        const platformBlocks = [];
        
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            blocks.push({
              x: x + col * blockSize,
              y: y + row * blockSize,
              width: blockSize,
              height: blockSize,
              type: 'normal'
            });
          }
        }
        
        return platformBlocks;
      }
      
      function generatePlatformPattern(x, y) {
        // Choose a platform pattern
        const patternType = Math.random();
        
        // Calculate available space to prevent overflow
        const availableWidth = Math.floor((canvasW - x) / blockSize);
        
        // Create different platform patterns based on probability
        if (patternType < 0.4) {
          // Simple horizontal platform (1x3, 1x4, etc.)
          const width = Math.min(Math.floor(Math.random() * 4) + 2, availableWidth); // FIXED: Cap to available space
          createPlatformBlocks(x, y, width, 1);
          return { width: width * blockSize, height: blockSize };
        } 
        else if (patternType < 0.65) {
          // L-shape platform
          const width = Math.min(Math.floor(Math.random() * 2) + 2, availableWidth); // FIXED: Cap to available space
          const height = 2; // 2 blocks tall (enough for player to jump through)
          
          // Horizontal part
          createPlatformBlocks(x, y, width, 1);
          
          // Vertical part
          createPlatformBlocks(x, y + blockSize, 1, height - 1);
          
          return { width: width * blockSize, height: height * blockSize };
        }
        else if (patternType < 0.8) {
          // Small square platform (2x2)
          const width = Math.min(2, availableWidth); // FIXED: Cap to available space
          createPlatformBlocks(x, y, width, 2);
          return { width: width * blockSize, height: 2 * blockSize };
        }
        else if (patternType < 0.9) {
          // Single block (allows the player to create path by destroying adjacent blocks)
          createPlatformBlocks(x, y, 1, 1);
          return { width: blockSize, height: blockSize };
        }
        else {
          // Wide platform with a gap (2-1-2 pattern) - FIXED: Only if enough space
          if (availableWidth >= 5) {
            createPlatformBlocks(x, y, 2, 1);
            createPlatformBlocks(x + 3 * blockSize, y, 2, 1);
            return { width: 5 * blockSize, height: blockSize };
          } else {
            // Fallback to simple platform
            const width = Math.min(availableWidth, 3);
            createPlatformBlocks(x, y, width, 1);
            return { width: width * blockSize, height: blockSize };
          }
        }
      }
      
      function generateInitialPlatforms() {
        blocks = [];
        platforms = [];
        
        // Add ground platform (full width)
        const groundY = canvasH - initialGroundHeight;
        const groundBlockCount = Math.floor(canvasW / blockSize);
        createPlatformBlocks(0, groundY, groundBlockCount, 1);
        
        // Generate several platforms below ground
        const numInitialPlatforms = 15;
        let lastY = groundY + 200; // Start below the ground
        
        for (let i = 0; i < numInitialPlatforms; i++) {
          // Generate a random x position for the platform - FIXED
          const maxX = canvasW - blockSize; // Ensure at least one block fits
          const x = Math.floor(Math.random() * maxX / blockSize) * blockSize;
          const y = lastY;
          
          // Generate a platform pattern at this position
          const platformInfo = generatePlatformPattern(x, y);
          
          // Maybe spawn an enemy on this platform (30% chance)
          if (Math.random() < 0.3 && i > 2) {
            const enemyX = x + Math.random() * Math.max(0, platformInfo.width - enemySize);
            const enemyY = y - enemySize;
            
            enemies.push({
              x: enemyX,
              y: enemyY,
              width: enemySize,
              height: enemySize,
              velocityX: 0,
              velocityY: 0,
              speed: 0.7 + Math.random() * 0.6, // Random speed between 0.7-1.3
              lastMoveTime: 0 // Track time for making movement decisions
            });
          }
          
          // Random vertical distance between platforms (with occasional bigger gaps)
          const gap = Math.random() < 0.2 ? 
                      Math.random() * 350 + 150 : 
                      Math.random() * 150 + 50;
          lastY += gap; // Move downward for next platform
        }
      }
      
      function generateNewPlatforms() {
        // If there are no blocks (first run) or blocks are getting low, generate more
        if (blocks.length === 0 || 
            blocks.reduce((bottom, blk) => blk.y > bottom ? blk.y : bottom, -Infinity) - cameraY < canvasH * 1.5) {
          
          // Find the bottom-most block
          const bottomY = blocks.reduce((bottom, blk) => blk.y > bottom ? blk.y : bottom, -Infinity);
          
          let newPlatformY = bottomY + Math.random() * 200 + 100;
          
          for (let i = 0; i < 8; i++) {
            // Occasionally create shafts with no platforms (20% chance)
            if (Math.random() < 0.2) {
              newPlatformY += Math.random() * 300 + 200;
              continue;
            }
            
            // Generate a random x position for the platform - FIXED
            const maxX = canvasW - blockSize; // Ensure at least one block fits
            const x = Math.floor(Math.random() * maxX / blockSize) * blockSize;
            const y = newPlatformY;
            
            // Generate a platform pattern at this position
            const platformInfo = generatePlatformPattern(x, y);
            
            // Maybe spawn an enemy (30% chance)
            if (Math.random() < 0.3) {
              const enemyX = x + Math.random() * Math.max(0, platformInfo.width - enemySize);
              const enemyY = y - enemySize;
              
              enemies.push({
                x: enemyX,  // Also fixed this from just x to enemyX
                y: enemyY,  // Fixed from blockY to enemyY
                width: enemySize,
                height: enemySize,
                velocityX: 0,
                velocityY: 0,
                speed: 0.7 + Math.random() * 0.6, // Random speed between 0.7-1.3
                lastMoveTime: 0
              });
            }
            
            // Random vertical distance between platforms
            const gap = Math.random() < 0.2 ? 
                        Math.random() * 400 + 200 : // Larger gaps for vertical shafts
                        Math.random() * 200 + 100;  // Regular gaps between platforms
            newPlatformY += gap; // Move downward for next platform
          }
        }
        
        // Clean up blocks that are far above the camera (no longer visible)
        blocks = blocks.filter(b => b.y - cameraY > -canvasH * 2);
        enemies = enemies.filter(e => e.y - cameraY > -canvasH * 2);
      }

      // --- Resize & initialize ---
      function resizeCanvas() {
        dpr = window.devicePixelRatio || 1;
        const rect = gameContainer.getBoundingClientRect();
        canvasW = rect.width;
        canvasH = rect.height;
        canvas.width = canvasW * dpr;
        canvas.height = canvasH * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        groundY = canvasH - initialGroundHeight;

        // initial placement
        if (!gameStarted) {
          player.x = canvasW / 2 - player.width / 2;
          resetPlayerOnGround();
          initializeHealthDisplay();
          generateInitialPlatforms();
          gameStarted = true;
        }
      }

      function initializeHealthDisplay() {
        healthDisplay.innerHTML = '';
        for (let i = 0; i < player.health; i++) {
          const healthUnit = document.createElement('div');
          healthUnit.className = 'health-unit';
          healthDisplay.appendChild(healthUnit);
        }
      }

      function resetPlayerOnGround() {
        player.y = groundY - player.height;
        player.velocityY = 0; // Reset vertical velocity
        player.canJump = true;
        shootPermissionGranted = false;
        player.ammo = maxAmmo;
        lastAmmo = player.ammo;
        ammoDisplay.textContent = `Ammo: ${player.ammo}/${maxAmmo}`;
      }
      
      function resetGame() {
        player.health = initialHealth;
        initializeHealthDisplay();
        score = 0;
        depthTraveled = 0;
        scoreDisplay.textContent = `Score: ${score}`;
        player.velocityY = 0;
        bullets = [];
        enemyProjectiles = [];
        pickups = [];
        cameraY = 0;
        gameOver = false;
        generateInitialPlatforms();
        resetPlayerOnGround();
      }

      function shoot() {
        const now = Date.now();
        if (player.ammo > 0 && now - lastShotTime > shootCooldown) {
          player.ammo--;
          lastShotTime = now;
          
          // Apply upward force to counteract gravity if falling
          if (!player.canJump && player.velocityY > 0) {
            // Reset vertical velocity to hover
            player.velocityY = 1; // Slight downward drift
          }
          
          // Create bullet going downward with timestamp for lifetime tracking
          bullets.push({
            x: player.x + player.width / 2 - bulletSize / 2,
            y: player.y + player.height,
            width: bulletSize,
            height: bulletSize * 2,
            velocityY: bulletSpeed,
            createdAt: now,
          });
          
          // Add screen shake effect
          screenShake = screenShakeDuration;
          
          // Play shoot sound
          shootSound();
          
          // Add visual hover effect (optional particle effect)
          createHoverEffect();
        }
      }
      
      // New function to create a visual hover effect
      function createHoverEffect() {
        // Create small upward particles for visual feedback
        for (let i = 0; i < 3; i++) {
          const particleSize = Math.random() * 3 + 2;
          const particleSpeed = Math.random() * 2 + 1;
          const particleX = player.x + Math.random() * player.width;
          
          bullets.push({
            x: particleX,
            y: player.y + player.height,
            width: particleSize,
            height: particleSize,
            velocityY: -particleSpeed, // Upward movement
            isEffect: true, // Mark as visual effect
            createdAt: Date.now(),
            lifetime: 300 // Short lifetime for effect particles
          });
        }
      }
      
      function checkBulletCollisions() {
        // Check player bullets against enemies and blocks
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          
          let bulletHit = false;
          
          // Check collisions with enemies
          for (let j = enemies.length - 1; j >= 0; j--) {
            const enemy = enemies[j];
            
            if (
              bullet.x < enemy.x + enemy.width &&
              bullet.x + bullet.width > enemy.x &&
              bullet.y < enemy.y + enemy.height &&
              bullet.y + bullet.height > enemy.y
            ) {
              // Enemy hit by bullet
              bullets.splice(i, 1);
              enemies.splice(j, 1);
              hitSound();
              score += enemyValue;
              bulletHit = true;
              
              // Chance to drop a pickup
              if (Math.random() < pickupDropChance) {
                pickups.push({
                  x: enemy.x + enemy.width / 2 - pickupSize / 2,
                  y: enemy.y + enemy.height / 2 - pickupSize / 2,
                  width: pickupSize,
                  height: pickupSize,
                  type: 'point'
                });
              }
              
              break;
            }
          }
          
          if (bulletHit) continue;
          
          // Check collisions with blocks
          for (let j = blocks.length - 1; j >= 0; j--) {
            const block = blocks[j];
            
            if (
              bullet.x < block.x + block.width &&
              bullet.x + bullet.width > block.x &&
              bullet.y < block.y + block.height &&
              bullet.y + bullet.height > block.y
            ) {
              // Block hit by bullet
              bullets.splice(i, 1);
              blocks.splice(j, 1);
              hitSound();
              score += blockDestructionValue;
              bulletHit = true;
              break;
            }
          }
          
          if (bulletHit) continue;
        }
      }
      
      function checkPlayerCollisions() {
        // Block collisions
        let isOnPlatform = false;
        
        // Group blocks by their Y coordinate for more efficient collision detection
        const blockRows = {};
        blocks.forEach(block => {
          const rowKey = Math.floor(block.y / blockSize);
          if (!blockRows[rowKey]) blockRows[rowKey] = [];
          blockRows[rowKey].push(block);
        });
        
        // Calculate the player's row
        const playerBottomRow = Math.floor((player.y + player.height) / blockSize);
        const checkRows = Math.min(2 + Math.floor(Math.abs(player.velocityY) / 10), 4); // Check more rows for fast-falling
        
        // Check collision with blocks in multiple rows below the player
        for (let rowOffset = 0; rowOffset <= checkRows; rowOffset++) {
          const blockRow = blockRows[playerBottomRow + rowOffset];
          if (!blockRow) continue;
          
          for (const block of blockRow) {
            // Check if player is on or landing on a block
            if (
              // Player's bottom edge is within the block's collision zone - increased tolerance
              player.y + player.height >= block.y - 8 &&
              player.y + player.height <= block.y + block.height/2 &&
              // Significantly more lenient horizontal overlap requirement (20% overlap)
              player.x + player.width * 0.8 > block.x &&
              player.x + player.width * 0.2 < block.x + block.width
            ) {
              // Only snap to block if player is falling or already on ground
              if (player.velocityY >= 0) {
                player.y = block.y - player.height;
                player.velocityY = 0;
                
                // If player wasn't on a platform before, play landing sound
                if (!player.canJump) {
                  landSound();
                  // Fully reload ammo when landing
                  player.ammo = maxAmmo;
                }
                
                player.canJump = true;
                shootPermissionGranted = false;
                isOnPlatform = true;
                break;
              }
            }
          }
          
          if (isOnPlatform) break;
        }
        
        // If not on any platform, the player is falling
        if (!isOnPlatform) {
          player.canJump = false;
          
          // Check if player fell off screen
          if (player.y - cameraY > canvasH + 100) {
            // Player fell off screen, lose health
            player.health--;
            updateHealthDisplay();
            hitSound();
            
            if (player.health <= 0) {
              gameOver = true;
              return;
            }
            
            // Reset player position to be visible on screen
            player.y = cameraY + 100;
            player.velocityY = 0;
            player.canJump = true;
            player.ammo = maxAmmo;
          }
        }
        
        // Enemy collisions - player jumps on enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
          const enemy = enemies[i];
          
          if (
            player.x < enemy.x + enemy.width &&
            player.x + player.width > enemy.x &&
            // Make sure we're checking if player's feet are at the top portion of enemy - more generous check
            player.y + player.height >= enemy.y &&
            player.y + player.height <= enemy.y + enemy.height * 0.6 && // Increased from 0.5 to 0.6
            player.y < enemy.y + enemy.height * 0.5 && // Make sure player's top is above enemy midpoint
            // Only count if player is falling down onto enemy
            player.velocityY > 0
          ) {
            // Player jumped on enemy
            enemies.splice(i, 1);
            hitSound();
            score += enemyValue;
            
            // Bounce the player
            player.velocityY = jumpStrength / 1.5;
            
            // Chance to drop a pickup
            if (Math.random() < pickupDropChance) {
              pickups.push({
                x: enemy.x + enemy.width / 2 - pickupSize / 2,
                y: enemy.y + enemy.height / 2 - pickupSize / 2,
                width: pickupSize,
                height: pickupSize,
                type: 'point'
              });
            }
          }
        }
        
        /* // Enemy projectile collisions with player
        if (player.invulnerable <= 0) {
          for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
            const proj = enemyProjectiles[i];
            
            if (
              proj.x < player.x + player.width &&
              proj.x + proj.width > player.x &&
              proj.y < player.y + player.height &&
              proj.y + proj.height > player.y
            ) {
              // Player hit by enemy projectile
              enemyProjectiles.splice(i, 1);
              player.health--;
              player.invulnerable = 60; // Give player invulnerability frames (60 frames ≈ 1 second)
              hitSound();
              updateHealthDisplay();
              
              if (player.health <= 0) {
                gameOver = true;
              }
              
              break;
            }
          }
        } */
        
        // Pickup collisions
        for (let i = pickups.length - 1; i >= 0; i--) {
          const pickup = pickups[i];
          
          if (
            player.x < pickup.x + pickup.width &&
            player.x + player.width > pickup.x &&
            player.y < pickup.y + pickup.height &&
            player.y + player.height > pickup.y
          ) {
            // Player collected pickup
            pickups.splice(i, 1);
            pickupSound();
            
            if (pickup.type === 'point') {
              score += pickupValue;
            }
          }
        }
      }

      function updateHealthDisplay() {
        if (player.health !== lastHealth) {
          healthDisplay.innerHTML = '';
          for (let i = 0; i < player.health; i++) {
            const healthUnit = document.createElement('div');
            healthUnit.className = 'health-unit';
            healthDisplay.appendChild(healthUnit);
          }
          lastHealth = player.health;
        }
      }

      function updateUI() {
        if (player.ammo !== lastAmmo) {
          ammoDisplay.textContent = `Ammo: ${player.ammo}/${maxAmmo}`;
          lastAmmo = player.ammo;
        }
        
        scoreDisplay.textContent = `Score: ${Math.floor(score)}`;
        
        updateHealthDisplay();
      }

      function gameLoop() {
        if (gameOver) {
          drawGameOver();
          return;
        }
        
        // --- Camera Movement ---
        // Always center the camera on the player
        const targetCameraY = player.y - canvasH / 2;
        
        // Use immediate camera positioning for smooth tracking
        cameraY = targetCameraY;
        
        // Add to score based on depth traveled only when moving down
        if (cameraY > depthTraveled) {
          score += (cameraY - depthTraveled) * 0.1;
          depthTraveled = cameraY;
        }
        
        // Generate new platforms as needed
        generateNewPlatforms();
        
        // --- Movement ---
        player.velocityX = 0;
        if (isMovingLeft) player.velocityX = -playerSpeed;
        if (isMovingRight) player.velocityX = playerSpeed;
        player.x += player.velocityX;

        // --- Linear falling & floating ---
        const isFloating = shootPermissionGranted && isJumpButtonPressed && player.ammo > 0 && !player.canJump;
        
        if (isFloating) {
          // Hover in place while shooting - almost zero gravity
          player.velocityY = 1; // Slight downward drift for visual effect
          shoot();
        }
        else if (!player.canJump) {
          // Create a more natural jump arc with variable gravity
          if (player.velocityY >= 0) {
            // Going down - use constant fall speed but ramp up to it more gradually
            if (player.velocityY < constantFallSpeed / 2) {
              // Start with a gentler descent
              player.velocityY += normalGravity * 1.2;
            } else {
              // Then transition to the constant fall speed
              player.velocityY = constantFallSpeed;
            }
          } else {
            // Going up - reduced gravity at the peak of the jump for "hangtime"
            if (player.velocityY > jumpStrength / 2) {
              // Near the peak, apply less gravity for more "float"
              player.velocityY += normalGravity * 0.7;
            } else {
              // Early in the jump, normal gravity
              player.velocityY += normalGravity;
            }
          }
        } else {
          // No vertical movement when on platform
          player.velocityY = 0;
        }
        
        // Cap falling speed to prevent getting too fast
        if (player.velocityY > maxFallingSpeed) {
          player.velocityY = maxFallingSpeed;
        }
        
        // Apply vertical movement
        player.y += player.velocityY;
        
        // Call collision detection *after* movement
        checkPlayerCollisions();

      

        // --- Decrease invulnerability timer ---
        if (player.invulnerable > 0) player.invulnerable--;

        // --- Horizontal bounds ---
        if (player.x < 0) player.x = 0;
        if (player.x + player.width > canvasW) player.x = canvasW - player.width;
        
        // --- Update enemies ---
        updateEnemies();
        
        // --- Check Bullet Collisions ---
        checkBulletCollisions();
        // Note: Player collisions are now checked right after player movement
        
        // --- Draw Everything ---
        ctx.fillStyle = "#2d3748";
        ctx.fillRect(0, 0, canvasW, canvasH);
        
        // Apply screen shake if active
        if (screenShake > 0) {
          screenShake--;
          screenShakeX = (Math.random() - 0.5) * 2 * screenShakeIntensity;
          screenShakeY = (Math.random() - 0.5) * 2 * screenShakeIntensity;
          ctx.save();
          ctx.translate(screenShakeX, screenShakeY);
        }

        // Platform blocks
        for (const block of blocks) {
          const screenY = block.y - cameraY; // Adjust for camera
          
          // FIXED: Only draw blocks that are fully or mostly visible
          if (screenY >= -5 && screenY <= canvasH + 5) { // Small tolerance for edge smoothing
            // Draw block using image if loaded, otherwise use fallback
            if (imageLoaded) {
              ctx.drawImage(blockImage, block.x, screenY, block.width, block.height);
            } else {
              // Fallback to original block rendering
              ctx.fillStyle = "#4a5568";
              ctx.fillRect(block.x, screenY, block.width, block.height);
              
              // Add texture to blocks (scaled to match larger block size)
              ctx.fillStyle = "#3a4559";
              ctx.fillRect(block.x + 3, screenY + 3, block.width - 6, 5);
              ctx.fillRect(block.x + 3, screenY + 12, block.width - 10, 4);
              ctx.fillRect(block.x + 8, screenY + 20, block.width - 16, 5);
            }
          }
        }

        // Reset screen shake transform if it was applied
        if (screenShake > 0) {
          ctx.restore();
        }
        
        // Pickups
        ctx.fillStyle = "#f6ad55"; // Orange color for pickups
        for (const pickup of pickups) {
          const screenY = pickup.y - cameraY; // Adjust for camera
          
          // FIXED: Only draw pickups that are fully or mostly visible
          if (screenY >= -5 && screenY <= canvasH + 5) { // Small tolerance for edge smoothing
            ctx.fillRect(pickup.x, screenY, pickup.width, pickup.height);
          }
        }

        /* // Enemy projectiles
        ctx.fillStyle = "#fc8181"; // Red projectiles
        for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
          const p = enemyProjectiles[i];
          p.y += p.velocityY;
          p.x += p.velocityX || 0;
          
          const screenY = p.y - cameraY;
          
          if (screenY <= -20 || screenY >= canvasH + 20 || p.x <= -20 || p.x >= canvasW + 20) {
            enemyProjectiles.splice(i, 1);
          } else {
            ctx.fillRect(p.x, screenY, p.width, p.height);
          }
        } */

        // Player bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          b.y += b.velocityY;
          
          const screenY = b.y - cameraY;
          
          // Check if this is a hover effect particle
          if (b.isEffect) {
            // Draw hover effect particles with fade out
            const age = Date.now() - b.createdAt;
            const opacity = 1 - (age / b.lifetime);
            
            if (age > b.lifetime) {
              bullets.splice(i, 1);
              continue;
            }
            
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(b.x, screenY, b.width, b.height);
            ctx.restore();
          } else {
            // Regular bullets
            ctx.save();
            ctx.shadowBlur = 10;
            ctx.shadowColor = "#ffd700";
            ctx.fillStyle = "#ffffff"; // Bright center
            ctx.fillRect(b.x + b.width/4, screenY, b.width/2, b.height);
            ctx.fillStyle = "#f6e05e"; // Yellow outer part
            ctx.fillRect(b.x, screenY, b.width, b.height);
            ctx.restore();
            
            // Remove bullets that go off screen or exceed their lifetime
            if (screenY > canvasH + 5 || screenY < -5 || Date.now() - b.createdAt > bulletLifetime) {
              bullets.splice(i, 1);
            }
          }
        }

        // Enemies
        for (const enemy of enemies) {
          const screenY = enemy.y - cameraY;
          
          // FIXED: Only draw enemies that are fully or mostly visible
          if (screenY >= -5 && screenY <= canvasH + 5) { // Small tolerance for edge smoothing
            // Draw floating effect (subtle up and down motion)
            const floatOffset = Math.sin(Date.now() / 200 + enemy.x) * 3;
            
            ctx.save();
            ctx.translate(enemy.x + enemy.width / 2, screenY + enemy.height / 2 + floatOffset);
            
            // Draw enemy - simple red square
            ctx.fillStyle = "#f56565"; // Red for enemies
            const halfSize = enemySize / 2;
            ctx.fillRect(-halfSize, -halfSize, enemySize, enemySize);
            
            ctx.restore();
          }
        }

        // Player (flashing when invulnerable)
        if (player.invulnerable <= 0 || Math.floor(player.invulnerable / 5) % 2 === 0) {
          ctx.save();
          ctx.translate(player.x + player.width / 2, player.y - cameraY + player.height / 2);
          ctx.fillStyle = playerColor;
          ctx.fill(playerPath);
          ctx.restore();
        }

        updateUI();
        requestAnimationFrame(gameLoop);
      }
      
      function updateEnemies() {
        const now = Date.now();
        
        for (let i = enemies.length - 1; i >= 0; i--) {
          const enemy = enemies[i];
          
          // Only update enemies that are on screen or close to it
          const screenY = enemy.y - cameraY;
          if (screenY < -100 || screenY > canvasH + 100) {
            continue; // Skip this enemy
          }
          
          // Update enemy's target direction toward player
          const dx = player.x - enemy.x;
          const dy = player.y - enemy.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // Make a movement decision every 500ms
          // This creates "dumber" AI that doesn't instantly react
          if (now - enemy.lastMoveTime > 500) {
            enemy.lastMoveTime = now;
            
            // Normalize direction vector
            if (distance > 0) {
              enemy.targetDirX = dx / distance;
              enemy.targetDirY = dy / distance;
            } else {
              enemy.targetDirX = 0;
              enemy.targetDirY = 0;
            }
          }
          
          // Apply movement toward player (with platform collision)
          if (distance < 400) { // Only move if player is within range
            // Gradually adjust velocity toward target direction (slow turning)
            enemy.velocityX = enemy.velocityX * 0.9 + enemy.targetDirX * enemy.speed * 0.1;
            enemy.velocityY = enemy.velocityY * 0.9 + enemy.targetDirY * enemy.speed * 0.1;
            
            // Cap maximum speed
            const currentSpeed = Math.sqrt(enemy.velocityX * enemy.velocityX + enemy.velocityY * enemy.velocityY);
            if (currentSpeed > enemy.speed) {
              enemy.velocityX = (enemy.velocityX / currentSpeed) * enemy.speed;
              enemy.velocityY = (enemy.velocityY / currentSpeed) * enemy.speed;
            }
            
            // Apply movement
            const newX = enemy.x + enemy.velocityX;
            const newY = enemy.y + enemy.velocityY;
            
            // Check for collision with platforms (dumb AI that gets stuck)
            let blocked = false;
            
            // Check platform collisions
            for (const block of blocks) {
              // Horizontal collision check
              if (newY < block.y + block.height && 
                  newY + enemy.height > block.y && 
                  newX < block.x + block.width && 
                  newX + enemy.width > block.x) {
                blocked = true;
                break;
              }
            }
            
            // Only move if not blocked
            if (!blocked) {
              enemy.x = newX;
              enemy.y = newY;
            } else {
              // If blocked, reverse direction briefly (bounce off walls)
              enemy.velocityX *= -0.5;
              enemy.velocityY *= -0.5;
            }
          }
          
          // Player collision (if not jumping on top)
          if (player.invulnerable <= 0 &&
              player.x < enemy.x + enemy.width &&
              player.x + player.width > enemy.x &&
              player.y < enemy.y + enemy.height &&
              player.y + player.height > enemy.y) {
                
              // Using a more generous definition of "jumping on top" to prevent false damage
              const jumpingOnEnemy = player.velocityY > 0 && 
                                     player.y + player.height >= enemy.y && 
                                     player.y + player.height <= enemy.y + enemy.height * 0.6 && // Increased from 0.5 to 0.6 (60% of enemy height)
                                     player.y < enemy.y + enemy.height * 0.5; // Make sure player's top is above the enemy midpoint
              
              if (!jumpingOnEnemy) {
                // Player hit by enemy from the side or below
                player.health--;
                player.invulnerable = 60; // Give player invulnerability frames (60 frames ≈ 1 second)
                hitSound();
                updateHealthDisplay();
                
                // Knock player back
                const knockbackDir = player.x < enemy.x ? -1 : 1;
                player.velocityX = knockbackDir * 8;
                player.velocityY = -5;
                
                if (player.health <= 0) {
                  gameOver = true;
                }
              }
          
          }
        }
      }
      
      function drawGameOver() {
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(0, 0, canvasW, canvasH);
        
        ctx.font = "bold 30px Poppins";
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", canvasW / 2, canvasH / 2 - 40);
        
        ctx.font = "20px Poppins";
        ctx.fillText(`Score: ${Math.floor(score)}`, canvasW / 2, canvasH / 2 + 10);
        ctx.fillText("Tap to restart", canvasW / 2, canvasH / 2 + 50);
        
        // Handle restart
        function restartHandler() {
          canvas.removeEventListener("click", restartHandler);
          canvas.removeEventListener("touchstart", restartHandler);
          resetGame();
          requestAnimationFrame(gameLoop);
        }
        
        canvas.addEventListener("click", restartHandler);
        canvas.addEventListener("touchstart", restartHandler);
      }

      function setupEventListeners() {
        const addBtnListener = (el, down, up) => {
          el.addEventListener("mousedown", down);
          el.addEventListener("mouseup", up);
          el.addEventListener("mouseleave", up);
          el.addEventListener(
            "touchstart",
            (e) => {
              e.preventDefault();
              down();
            },
            { passive: false },
          );
          el.addEventListener(
            "touchend",
            (e) => {
              e.preventDefault();
              up();
            },
            { passive: false },
          );
        };

        addBtnListener(
          leftBtn,
          () => {
            if (!gameOver) isMovingLeft = true;
          },
          () => (isMovingLeft = false),
        );
        addBtnListener(
          rightBtn,
          () => {
            if (!gameOver) isMovingRight = true;
          },
          () => (isMovingRight = false),
        );

        addBtnListener(
          jumpBtn,
          () => {
            if (gameOver) {
              resetGame();
              return;
            }
            
            isJumpButtonPressed = true;
            if (player.canJump) {
              player.velocityY = jumpStrength;
              player.canJump = false;
            } else {
              shootPermissionGranted = true;
              shoot();
            }
          },
          () => {
            isJumpButtonPressed = false;
          },
        );
        
        // Keyboard controls
        window.addEventListener("keydown", (e) => {
          if (gameOver) {
            if (e.key === ' ' || e.key === 'Enter') {
              resetGame();
              return;
            }
          }
          
          if (e.key === "ArrowLeft" || e.key === "a") isMovingLeft = true;
          if (e.key === "ArrowRight" || e.key === "d") isMovingRight = true;
          if (e.key === "ArrowUp" || e.key === "w" || e.key === " ") {
            isJumpButtonPressed = true;
            if (player.canJump) {
              player.velocityY = jumpStrength;
              player.canJump = false;
            } else {
              shootPermissionGranted = true;
              shoot();
            }
          }
        });
        
        window.addEventListener("keyup", (e) => {
          if (e.key === "ArrowLeft" || e.key === "a") isMovingLeft = false;
          if (e.key === "ArrowRight" || e.key === "d") isMovingRight = false;
          if (e.key === "ArrowUp" || e.key === "w" || e.key === " ") {
            isJumpButtonPressed = false;
          }
        });
      }

      window.addEventListener("resize", resizeCanvas);

      // --- Init ---
      resizeCanvas();
      setupEventListeners();
      gameLoop();
    </script>
  </body>
</html>